{% extends "base.html" %}
{% block body %}
    <div class="container pt-3">
        <h4>My Questions</h4>

		<div class="row">
			<span class="dropdown">
				<button class="btn btn-link dropdown-toggle text-decoration-none" type="button" id="newQuestionButton" data-bs-toggle="dropdown" aria-expanded="false">
					<i class="bi-plus-circle"></i>
					Create New Question
				</button>
				<ul class="dropdown-menu" aria-labelledby="newQuestionButton">
					<li><a class="dropdown-item" href="{{url_for('instructor.create_new_question', question_type='short-answer')}}">Short Answer (Self-Graded)</a></li>
					<li><a class="dropdown-item" href="{{url_for('instructor.create_new_question', question_type='auto-check')}}">Short Answer (Auto-Graded)</a></li>
					<li><a class="dropdown-item" href="{{url_for('instructor.create_new_question', question_type='multiple-choice')}}">Multiple Choice</a></li>
					<li><a class="dropdown-item" href="{{url_for('instructor.create_new_question', question_type='code-jumble')}}">Code Jumble</a></li>
				</ul>
			</span>
		</div>

		<div class="row" id="currentQuestions">
			<confirmation-dialog name="confirmationModal"
				 @confirmed="resolveConfirmation(true)"
				 @cancelled="resolveConfirmation(false)">
				Are you sure you want to delete these questions.
				<strong>This action cannot be undone.</strong>
			</confirmation-dialog>


			<ul class="list-unstyled" v-if="all_questions.length > 0">
				<li class="m-2">
					<div class="container row">
						<div class="col-auto border pt-2"
							:class="{'bg-light': selected_indices.length !== displayed_questions.length, 'bg-primary bg-gradient': selected_indices.length === displayed_questions.length}">
							<input id="massSelect" type="checkbox"
								v-model="mass_select"
								:checked="selected_indices.length === displayed_questions.length">
							<label for="massSelect" class="visually-hidden">Select All/None</label>
						</div>

						<div class="col-10 p-1 border-top border-bottom d-flex align-items-center"
							style="min-height: 2.75rem">
							<div v-if="selected_indices.length === 0" class="mx-2">
								Filter:
								<span class="pb-2" :class="noActiveFilter">
									<button role="button" class="btn btn-link text-decoration-none link-secondary"
							   				:class="current_filter === '' ?  'link-dark' : 'link-secondary'"
										   @click="setFilteredQuestions(all_questions); current_filter = ''">
										All
									</button>
								</span>

								<span class="pb-2" :class="filterNoObjective">
									<button role="button" class="btn btn-link text-decoration-none link-secondary"
												:class="current_filter === 'no_lo' ?  'link-dark' : 'link-secondary'"
										@click="filterByMissingObjective">
										Missing Learning Objective
									</button>
								</span>

								<span class="pb-2" :class="filterDisabled">
									<button role="button" class="btn btn-link text-decoration-none link-secondary"
											:class="current_filter === 'disabled' ?  'link-dark' : 'link-secondary'"
										@click="filterByDisabled">
										Disabled
									</button>
								</span>
							</div>

							<div v-else class="mx-2">
								<div class="btn-group mx-2">
									<button type="button" class="btn btn-sm btn-secondary dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">
										<i class="bi-tag"></i>
										Learning Objective
									</button>
									<ul class="dropdown-menu">
										<li><button class="dropdown-item" type="button"
													data-bs-toggle="modal" data-bs-target="#setObjectiveModal">
												<i class="bi-plus-circle"></i>
												Set Objective</button>
										</li>
										<li><button class="dropdown-item" type="button" @click="removeObjectiveFromSelected">
												<i class="bi-x-circle"></i>
												Remove Objective</button>
										</li>
									</ul>
								</div>
								<div class="btn-group mx-2">
									<button type="button" class="btn btn-sm btn-secondary dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">
										<i class="bi-tools"></i>
										Settings
									</button>
									<ul class="dropdown-menu">
										<li><button class="dropdown-item" type="button"
														@click="updateSelectedQuestions('public', true)">
												<i class="bi-people"></i>
												Mark as Public</button></li>
										<li><button class="dropdown-item" type="button"
														@click="updateSelectedQuestions('public', false)">
												<i class="bi-person"></i>
												Mark as Private</button></li>
										<li><hr class="dropdown-divider"></li>
										<li><button class="dropdown-item" type="button"
														@click="updateSelectedQuestions('enabled', true)">
												<i class="bi-eye"></i>
												Mark as Enabled</button></li>
										<li><button class="dropdown-item" type="button"
														@click="updateSelectedQuestions('enabled', false)">
												<i class="bi-eye-slash"></i>
												Mark as Disabled</button></li>
									</ul>
								</div>

								<button type="button" class="btn btn-sm btn-danger" @click="deleteSelected">
									<i class="bi-trash"></i>
									Delete
								</button>
							</div>
						</div>
						<div class="col-1 pt-2 border border-start-0">
						</div>
					</div>
				</li>

				<li class="m-2"
					v-for="(q, index) in displayed_questions" :key="q.id">
					<div class="container row">
						<div class="col-auto pt-2 border"
							:class="{'bg-light': !selected_indices.includes(index), 'bg-primary bg-gradient': selected_indices.includes(index)}">
							<input 
									:id="`q${index}`" :value=index v-model.number="selected_indices"
									name="aQuestion" type="checkbox">
							<label :for="`q${index}`" class="visually-hidden">Question with ID [[q.id]]</label>
						</div>
						<div class="col-10 p-1 border-top border-bottom">

							<table class="table table-borderless table-sm">
								<tbody>
									<tr>
										<th scope="row" class="col-1">Type:</th>
										<td>[[ typeStrings[index] ]]</td>
									</tr>
									<tr>
										<th scope="row">Prompt:</th>
										<td>
											<div class="clippy" v-html="convertToHtml(q.prompt)"></div>
										</td>
									</tr>
									<tr>
										<th scope="row">Learning Objective:</th>
										<td v-if="q.objective"
											v-html="convertToHtml(q.objective['description'])">
										</td>
										<td v-else>
											None
										</td>
									</tr>
									<tr>
										<th scope="row">Public:</th>
										<td>
											<span class="text-success" v-if="q.public">
												<i class="bi-check-circle"></i>
											</span>
											<span class="text-danger" v-else>
												<i class="bi-x-circle"></i>
											</span>
										</td>
									</tr>
									<tr>
										<th scope="row">Enabled:</th>
										<td>
											<span class="text-success" v-if="q.enabled">
												<i class="bi-check-circle"></i>
											</span>
											<span class="text-danger" v-else>
												<i class="bi-x-circle"></i>
											</span>
										</td>
									</tr>
								</tbody>
							</table>
						</div>
						<div class="col-auto pt-2 border border-start-0">
							<i class="bi-pencil-square"></i>
							<a class="text-decoration-none text-secondary" :href="'/q/' +  q.id  + '/edit'">
								Edit
							</a>
							<br/>
							<i class="bi-eye"></i>
							<a class="text-decoration-none text-secondary" :href="'/q/' +  q.id  + '/preview'">
								Preview
							</a>
						</div>
					</div>
				</li>
			</ul>

			<pagination-control
				class="mt-3"
				description="Page navigation for questions"
				:num_items="filtered_questions.length"
				:items_per_page="questions_per_page"
				@selected-page="setDisplayedQuestions">
			</pagination-control>

			<set-objective-modal 
			   name="setObjectiveModal"
				  @objective-set="setObjectiveInSelected"
				  @created-new-objective="displayMessage('Successfully created a new objective.')"
				  @failed-to-create="displayMessage('Failed to create objective.')"
                  @failed-to-search="displayMessage('Failed to obtain search results.')">
			</set-objective-modal>
		</div>


	</div>

	<div id="snackbar">Default message.</div> 

    <script src="{{ url_for('static', filename='js/showdown.min.js') }}"></script>
    <script src="https://unpkg.com/vue@3"></script>

	<script src="{{ url_for('static', filename='js/helpers.js') }}" type="module"></script>
	<script src="{{ url_for('static', filename='js/cadet-api.js') }}" type="module"></script>
	<script src="{{ url_for('static', filename='js/confirmation-dialog.js') }}" type="module"></script>


	<script type="module">
		import { fetchOrRefresh, getCookie, showSnackbarMessage } from '/static/js/helpers.js';
		import * as CadetApi from '/static/js/cadet-api.js';
		import ConfirmationDialog from '/static/js/confirmation-dialog.js';
		import SetObjectiveModal from '/static/js/objective-modal.js';
		import PaginationControl from '/static/js/pagination-control.js';

        const converter = new showdown.Converter();
        const refresh_url = "{{ url_for('auth.refresh_jwts') }}";

        const app = Vue.createApp({
            data() {
                return {
					all_questions: [],
                    filtered_questions: [], // subset of all_questions that may be displayed
					displayed_questions: [], // subset of filtered_questions that are actually displayed
					questions_per_page: 10,

					target_user: {{ target_author }},
					selected_indices: [],
					mass_select: false,
					current_filter: "",
					resolveConfirmation: undefined,
                }
            },

			components: {
				ConfirmationDialog,
				SetObjectiveModal,
				PaginationControl,
			},

			computed: {
				typeStrings() {
					return this.displayed_questions.map(this.getTypeString);
				},

				noActiveFilter() {
					return this.getStyle(this.current_filter === '');
				},

				filterNoObjective() {
					return this.getStyle(this.current_filter === 'no_lo');
				},

				filterDisabled() {
					return this.getStyle(this.current_filter === 'disabled');
				},
			},

			watch: {
				mass_select(checkedNow, wasChecked) {
					this.selected_indices = [];
					if (checkedNow) {
						for (let i = 0; i < this.displayed_questions.length; i++) {
							this.selected_indices.push(i);
						}
					}
				},
			},

            methods: {
				displayMessage(msg) {
					showSnackbarMessage(msg);
				},

				getStyle(b) {
					return {
						'border-bottom': b,
						'border-primary': b,
						'border-3': b,
					}
				},

                setDisplayedQuestions(start, end) {
                    this.displayed_questions = this.filtered_questions.slice(start, end);
                },

				/* Update array of questions to display and deselects all
				questions. */
				setFilteredQuestions(questions_to_display) {
					this.filtered_questions.length = 0;
					this.filtered_questions.push(...questions_to_display);
					this.selected_indices.length = 0;
					this.setDisplayedQuestions(0, Math.min(this.filtered_questions.length, this.questions_per_page));
				},

				filterByMissingObjective() {
					const without_objectives = this.all_questions.filter(q => q.objective === null);
					this.setFilteredQuestions(without_objectives);
					this.current_filter = "no_lo";
				},

				filterByDisabled() {
					const disabled_questions = this.all_questions.filter(q => !q.enabled);
					this.setFilteredQuestions(disabled_questions);
					this.current_filter = "disabled";
				},

				async setObjectiveInSelected(objective_id) {
					let updated_indices = [];
					let failed_indices = [];

					for (const index of this.selected_indices) {
						const q_id = this.displayed_questions[index].id;
						const response = await CadetApi.setQuestionObjective(q_id, objective_id);

						if (response.ok) {
							updated_indices.push(index);
							const r = await response.json()
							this.displayed_questions[index].objective = r["updated"].objective;
						}
						else {
							failed_indices.push(index);
						}
					}

					showSnackbarMessage(`Successfully updated ${updated_indices.length} questions. Failures: ${failed_indices.length}`);
				},

				async removeObjectiveFromSelected() {
					let updated_indices = [];
					let failed_indices = [];

					for (const index of this.selected_indices) {
						if (this.displayed_questions[index].objective === null) {
							updated_indices.push(index);
							continue;
						}

						const q_id = this.displayed_questions[index].id;
						const response = await CadetApi.removeQuestionObjective(q_id);

						if (response.ok) {
							updated_indices.push(index);
							this.displayed_questions[index].objective = null;
						}
						else {
							failed_indices.push(index);
						}
					}

					showSnackbarMessage(`Successfully removed objective from ${updated_indices.length} questions. Failures: ${failed_indices.length}`);
				},

                async updateSelectedQuestions(field_name, field_value) {
					let updated_indices = [];
					let failed_indices = [];

					// TRICKY: reverse sort the list so to avoid issues with
					// non-existent indices
					this.selected_indices.sort((a,b) => b - a);
					for (const index of this.selected_indices) {
						if (this.displayed_questions[index][field_name] === field_value) {
							// skip updating those questions whose field value is
							// already set to the desired value
							updated_indices.push(index);
							continue;
						}

						const q_id = this.displayed_questions[index].id;
						try {
							await CadetApi.updateQuestionField(field_name, field_value, q_id);
						} catch {
							failed_indices.push(index);
							continue;
						}

						updated_indices.push(index);
						this.displayed_questions[index][field_name] = field_value;
					}

					showSnackbarMessage(`Successfully updated ${updated_indices.length} questions. Failures: ${failed_indices.length}`);
                },

				getConfirmation() {
					const modal_el = document.getElementById('confirmationModal');
					const confirmation_modal = new bootstrap.Modal(document.getElementById('confirmationModal'));
					confirmation_modal.show();

					return new Promise((resolve, reject) => {
						this.resolveConfirmation = resolve
					});
				},

				removeQuestion(target_arr, question_id) {
					const target_index = target_arr.findIndex(q => q.id === question_id);
					if (target_index != -1) {
						target_arr.splice(target_index, 1);
					}
				},

				async deleteSelected() {
					// get confirmation first
					const confirmation = await this.getConfirmation();

					// if resolved to true, then we can delete
					if (confirmation) {
						let deleted_indices = [];
						let failed_indices = [];
						const original_indices = [...this.selected_indices];

						// TRICKY: sort indices in reverse order so indices
						// don't get thrown off when removing from this.questions
						original_indices.sort( (a,b) => { return b - a; } );

						for (const index of original_indices) {
							const q_id = this.displayed_questions[index].id;
							const response = await CadetApi.deleteQuestion(q_id);
							if (response.ok) {
								deleted_indices.push(index);
								this.displayed_questions.splice(index, 1);
								this.removeQuestion(this.all_questions, q_id);
								this.removeQuestion(this.filtered_questions, q_id);
							}
							else {
								failed_indices.push(index);
							}
						}

						showSnackbarMessage(`Successfully deleted ${deleted_indices.length} questions. Failures: ${failed_indices.length}`);
						this.selected_indices = failed_indices;
					}
				},

                async getQuestions() {
                    let url = "{{ url_for('questions_api') }}";
					url = url + `?author=${this.target_user}`;

                    const response = await fetchOrRefresh(url, 'GET', refresh_url);
                    if (response.ok) {
                        const r = await response.json();
                        this.all_questions = r["questions"];
						this.setFilteredQuestions(this.all_questions);
						this.setDisplayedQuestions(0, Math.min(this.filtered_questions.length, this.questions_per_page));
                    }
                    else {
                        showSnackbarMessage(`Error loading questions. Try again. (HTTP Status: ${response.status})`);
                    }
                },

                convertToHtml(md_text) {
                    return converter.makeHtml(md_text);
				},

				getTypeString(q) {
					switch (q.type) {
						case 'short-answer':
							return "Short Answer (Self-Graded)";
						case 'auto-check':
							return "Short Answer (Auto-Graded)";
						case 'multiple-choice':
							return "Multiple Choice";
						case 'code-jumble':
							return "Code Jumble";
						default:
							return q.type;
					}
				},
            },

            created() {
                this.getQuestions();
            },

            compilerOptions: {
                delimiters: ["[[", "]]"]
            },
        });
        
        const vm = app.mount('#currentQuestions');
	</script>
{% endblock %}
