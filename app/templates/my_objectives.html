{% extends "base.html" %}
{% block body %}
    <div class="container pt-3">
        <h4>My Learning Objectives</h4>

		<a href="{{ url_for('instructor.create_new_objective') }}"
			class="text-decoration-none ms-2">
			<i class="bi-plus-circle"></i>
			Create New Objective
		</a>

		<div class="row" id="currentObjectives">
			<confirmation-dialog name="confirmationModal"
				 @confirmed="resolveConfirmation(true)"
				 @cancelled="resolveConfirmation(false)">
				Are you sure you want to delete these objectives.
				<strong>This action cannot be undone.</strong>
			</confirmation-dialog>


			<ul class="list-unstyled">
				<li class="m-2">
					<div class="container row">
						<div class="col-auto border pt-2"
							:class="{'bg-light': mass_select_state !== 'checked', 'bg-primary bg-gradient': mass_select_state === 'checked'}">
							<input id="massSelect" type="checkbox" @click="toggle_mass_select">
							<label for="massSelect" class="visually-hidden">Select All/None</label>
						</div>

						<div class="col-10 p-1 border-top border-bottom d-flex align-items-center"
							style="min-height: 2.75rem">
							<div v-if="selected_indices.length > 0" class="mx-2">
								<div class="btn-group mx-2">
									<button type="button" class="btn btn-sm btn-secondary dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">
										<i class="bi-tag"></i>
										Topic
									</button>
									<ul class="dropdown-menu">
										<li><button class="dropdown-item" type="button"
													data-bs-toggle="modal" data-bs-target="#setTopicModal">
												<i class="bi-plus-circle"></i>
												Set Topic</button>
										</li>
										<li><button class="dropdown-item" type="button" @click="removeTopicFromSelected">
												<i class="bi-x-circle"></i>
												Remove Topic</button>
										</li>
									</ul>
								</div>

								<div class="btn-group mx-2">
									<button type="button" class="btn btn-sm btn-secondary dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">
										<i class="bi-tools"></i>
										Settings
									</button>
									<ul class="dropdown-menu">
										<li><button class="dropdown-item" type="button"
														@click="updateSelectedObjectives('public', true)">
												<i class="bi-people"></i>
												Mark as Public</button></li>
										<li><button class="dropdown-item" type="button"
														@click="updateSelectedObjectives('public', false)">
												<i class="bi-person"></i>
												Mark as Private</button></li>
									</ul>
								</div>

								<button type="button" class="btn btn-sm btn-danger" @click="deleteSelected">
									<i class="bi-trash"></i>
									Delete
								</button>
							</div>

							<keep-alive>
								<filter-control v-if="selected_indices.length === 0" class="ms-2"
								  :filters="[{name: 'All', func: () => true}, {name: 'Missing Topic', func: lo => lo.topic === null}, {name: 'Private', func: lo => lo.public === false}, {name: 'Public', func: lo => lo.public}]"
									@selected-filter="f => (current_filter = f)">
								</component>
							</keep-alive>

						</div>
						<div class="col-1 pt-2 border border-start-0">
						</div>
					</div>
				</li>

				<li class="m-2"
					v-for="(objective, index) in displayed_objectives" :key="objective.id">
					<div class="container row">
						<!-- Column with checkbox -->
						<div class="col-auto pt-2 border"
							:class="{'bg-light': !selected_indices.includes(index), 'bg-primary bg-gradient': selected_indices.includes(index)}">
							<input 
									:id="`o${index}`" :value=index v-model.number="selected_indices"
									name="anObjective" type="checkbox">
							<label :for="`o${index}`" class="visually-hidden">Objective with ID [[objective.id]]</label>
						</div>

						<!-- Column with table of objective info -->
						<div class="col-10 p-1 border-top border-bottom">
							<table class="table table-borderless table-sm mb-0">
								<tbody>
									<tr>
										<th scope="row">Topic:</th>
										<td v-if="objective.topic">
											<button type="button" class="btn btn-light btn-sm">
												[[ objective.topic.text ]]
												<i class="bi-x" @click="removeTopic(objective)"></i>
											</button>
										</td>
										<td v-else>
											<em>None</em>
										</td>
									</tr>

									<tr>
										<th scope="row" class="col-1">Description:</th>
										<td class="inline-p" v-html="convertToHtml(objective.description)"></td>
									</tr>

									<tr>
										<th scope="row">Public:</th>
										<td>
											<span class="text-success" v-if="objective.public">
												<i class="bi-check-circle"></i>
											</span>
											<span class="text-danger" v-else>
												<i class="bi-x-circle"></i>
											</span>
										</td>
									</tr>
								</tbody>
							</table>
						</div>

						<!-- Column with actions only for individual objectives -->
						<div class="col-1 pt-2 border border-start-0">
							<i class="bi-pencil-square"></i>
							<a class="text-decoration-none text-secondary" :href="'/lo/' +  objective.id  + '/edit'">
								Edit
							</a>
						</div>

					</div>
				</li>
			</ul>

			<pagination-control
				class="mt-3"
				description="Page navigation for objectives"
				:num_items="filtered_objectives.length"
				:items_per_page="objectives_per_page"
				@selected-page-num="(pn) => (current_page_num = pn)">
			</pagination-control>

			<set-topic-modal 
			   name="setTopicModal"
				  @topic-set="setTopicInSelected"
				  @created-new-topic="displayMessage('Successfully created a new topic.')"
				  @failed-to-create="displayMessage('Failed to create topic.')"
                  @failed-to-search="displayMessage('Failed to obtain search results.')">
			</set-objective-modal>
		</div>

	</div>

	<div id="snackbar">Default message.</div> 

    <script src="{{ url_for('static', filename='js/showdown.min.js') }}"></script>


	<script type="module">
		import { fetchOrRefresh, getCookie, showSnackbarMessage, findAndRemove } from '/static/js/helpers.js';
		import { createApp, ref } from '/static/js/vue.esm-browser.js';
		import * as CadetApi from '/static/js/cadet-api.js';
		import ConfirmationDialog from '/static/js/confirmation-dialog.js';
		import SetTopicModal from '/static/js/topic-modal.js';
		import { useFilterableList, usePagination } from '/static/js/filterable-lists.js';
		import PaginationControl from '/static/js/pagination-control.js';
		import FilterControl from '/static/js/filter-control.js';

        const converter = new showdown.Converter();
        const refresh_url = "{{ url_for('auth.refresh_jwts') }}";

        const app = createApp({
			setup() {
				const current_filter = ref(() => true);

				const { all_data: all_objectives,
						filtered_data: filtered_objectives,
						error: fetch_errors } = useFilterableList(Flask.url_for('objectives_api', {'author': 'self'}), "learning_objectives", current_filter);

				const objectives_per_page = ref(10);
				const current_page_num = ref(0);
				const { current_page: displayed_objectives } = usePagination(filtered_objectives, objectives_per_page, current_page_num);
				return { all_objectives, filtered_objectives, current_filter, current_page_num, displayed_objectives, objectives_per_page };
			},

            data() {
                return {
					target_user: {{ target_author }},
					selected_indices: [],
					resolveConfirmation: undefined,
                }
            },

			components: {
				ConfirmationDialog,
				SetTopicModal,
				PaginationControl,
				FilterControl,
			},

			computed: {
				mass_select_state() {
					if (this.selected_indices.length === this.displayed_objectives.length) {
						return "checked";
					}
					else if (this.selected_indices.length === 0) {
						return "unchecked";
					}
					else {
						return "indeterminate";
					}
				},
			},

			watch: {
				displayed_objectives(newDisplayed, oldDisplayed) {
					this.selected_indices = [];
				},

				mass_select_state(newVal, oldVal) {
					const checkbox = document.getElementById('massSelect');
					if (newVal === "checked") {
						checkbox.checked = true;
						checkbox.indeterminate = false;
					}
					else if (newVal === "unchecked") {
						checkbox.checked = false;
						checkbox.indeterminate = false;
					}
					else {
						checkbox.checked = false;
						checkbox.indeterminate = true;
					}
				},
			},

            methods: {
				displayMessage(msg) {
					showSnackbarMessage(msg);
				},

				toggle_mass_select() {
					if (this.mass_select_state === "unchecked") {
						// was unchecked so select all!
						this.selected_indices = [];
						for (let index = 0; index < this.displayed_objectives.length; index++) {
							this.selected_indices.push(index);
						}
					}
					else {
						// was partially or fully checked so deselect all
						this.selected_indices = [];
					}
				},

				async removeTopic(objective) {
					const response = await CadetApi.removeObjectiveTopic(objective.id);
					if (response.ok) {
						objective.topic = null;
					}
					else {
						showSnackbarMessage("Error removing topic. Try again later.");
					}
				},

				async setTopicInSelected(topic_id) {
					let failures = [];

					const objectives_to_update = this.selected_indices.map(index => this.displayed_objectives[index]);

					for (const lo of objectives_to_update) {
						try {
							const updated_objective = await CadetApi.setObjectiveTopic(lo.id, topic_id);
							lo.topic = updated_objective.topic;
						} catch {
							failures.push(lo);
						}
					}

					if (failures.length > 0) {
						showSnackbarMessage(`Failed to update ${failures.length} objectives.`);
					}
				},

				async removeTopicFromSelected() {
					let updated_indices = [];
					let failed_indices = [];

					for (const index of this.selected_indices) {
						if (this.displayed_objectives[index].topic === null) {
							updated_indices.push(index);
							continue;
						}

						const o_id = this.displayed_objectives[index].id;
						const response = await CadetApi.removeObjectiveTopic(o_id);

						if (response.ok) {
							updated_indices.push(index);
							this.displayed_objectives[index].topic = null;
						}
						else {
							failed_indices.push(index);
						}
					}

					showSnackbarMessage(`Successfully removed topic from ${updated_indices.length} objectives. Failures: ${failed_indices.length}`);
				},

                async updateSelectedObjectives(field_name, field_value) {
					let updated_indices = [];
					let failed_indices = [];

					// TRICKY: reverse sort the list so to avoid issues with
					// non-existent indices
					this.selected_indices.sort((a,b) => b - a);
					for (const index of this.selected_indices) {
						if (this.displayed_objectives[index][field_name] === field_value) {
							// skip updating those objectives whose field value is
							// already set to the desired value
							updated_indices.push(index);
							continue;
						}

						const o_id = this.displayed_objectives[index].id;

						try {
							await CadetApi.updateObjectiveField(field_name, field_value, o_id);
						} catch(e) {
							failed_indices.push(index);
							continue;
						}

						updated_indices.push(index);
						this.displayed_objectives[index][field_name] = field_value;
					}

					showSnackbarMessage(`Successfully updated ${updated_indices.length} objectives. Failures: ${failed_indices.length}`);
                },

				getConfirmation() {
					const modal_el = document.getElementById('confirmationModal');
					const confirmation_modal = new bootstrap.Modal(document.getElementById('confirmationModal'));
					confirmation_modal.show();

					return new Promise((resolve, reject) => {
						this.resolveConfirmation = resolve
					});
				},

				async deleteSelected() {
					// get confirmation first
					const confirmation = await this.getConfirmation();

					// if resolved to true, then we can delete
					if (confirmation) {
						let deleted_indices = [];
						let failed_indices = [];
						const original_indices = [...this.selected_indices];

						// TRICKY: sort indices in reverse order so indices
						// don't get thrown off when removing from this.all_objectives
						original_indices.sort( (a,b) => { return b - a; } );

						for (const index of original_indices) {
							const o_id = this.displayed_objectives[index].id;
							const response = await CadetApi.deleteObjective(o_id);
							if (response.ok) {
								deleted_indices.push(index);
								findAndRemove(this.all_objectives, o_id);
							}
							else {
								failed_indices.push(index);
							}
						}

						showSnackbarMessage(`Successfully deleted ${deleted_indices.length} objectives. Failures: ${failed_indices.length}`);
						this.selected_indices = [];
					}
				},

                async getObjectives() {
                    let url = "{{ url_for('objectives_api') }}";
					url = url + `?author=${this.target_user}`;

                    const response = await fetchOrRefresh(url, 'GET', refresh_url);
                    if (response.ok) {
                        const r = await response.json();
                        this.all_objectives = r["learning_objectives"];
                    }
                    else {
                        showSnackbarMessage("Error loading learning objectives.");
                    }
                },

                convertToHtml(md_text) {
                    return converter.makeHtml(md_text);
				},
            },

            created() {
                //this.getObjectives();
            },

            compilerOptions: {
                delimiters: ["[[", "]]"]
            },
        });
        
        const vm = app.mount('#currentObjectives');
	</script>
{% endblock %}
